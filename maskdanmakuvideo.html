<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mask Example</title>
<style>
:root {
    --aspect-ratio: 1920/1080; /* è®¾ç½®å®½é«˜æ¯”ä¾‹ */
    --size: 1400px; 
    --width: var(--size);
    --height: calc(var(--size) / calc(1 * var(--aspect-ratio))); /* ä½¿ç”¨ calc() å‡½æ•°è®¡ç®—é«˜åº¦ */
    --danmaku-item-height: 30px;
    --danmaku-columns: 20;
    --danmaku-rows: 30;
    --danmaku-threshold: 0.7;
}

body {
    margin: 0;
}

.container{
    position: relative;
    width: var(--width);
    height: var(--height);
    background-color:blue ;
    overflow: hidden;
}

#videoPlayer {
    position: absolute;
    width: 100%;
    height: 100%;
}

#danmakuLayer {
    position: absolute;
    width: 100%;
    height: 100%;
    /* background-color:rgba(0, 0, 255, 0.5); åŠé€æ˜è“è‰² */
    pointer-events: none;
}

.danmu {
    position: absolute;
    white-space: nowrap;
}

</style>
</head>
<body>
    <div class="container">
        <!-- åº•å±‚è§†é¢‘ -->
        <video id="videoPlayer" controls>
            <source src="cxk.mp4" type="video/mp4">
        </video>
        <!-- ä¸Šå±‚å¼¹å¹• -->
        <div id="danmakuLayer">
        </div>
    </div>
    <script src="masksvg.js"></script>
    <script src="binarysearchtree.js"></script>
    <script>
        const danmakuMaskCount = Object.keys(masksvgList).length
        const videoDuration = 59
        const danmakuMaskBlock = videoDuration * 1000 / danmakuMaskCount;
        console.log(danmakuMaskBlock)

        // å°† mask å¸§è½¬æˆäºŒå‰æœç´¢æ ‘
        const maskbst = objectToBST(masksvgList);

        
        // è·å–è§†é¢‘å’Œå¼¹å¹•å±‚
        const videoPlayer = document.getElementById('videoPlayer');
        const danmakuLayer = document.getElementById('danmakuLayer');

        let shouldStopTask = false;

        // ç›‘å¬è§†é¢‘æ’­æ”¾è¿›åº¦äº‹ä»¶
        videoPlayer.ontimeupdate = (event) => {
            // const currentTime = videoPlayer.currentTime * 1000;
            // // è½¬æ¢æˆ mask å›¾ç‰‡ä¸‹è¡¨
            // const maskOffset = currentTime / danmakuMaskBlock
            // const pointOffset = Math.floor(maskOffset)
        };
    
        videoPlayer.onplay = (event) => {
            console.log("play")
            // const currentTime = Math.floor(videoPlayer.currentTime * 1000);
            // è½¬æ¢æˆ mask å›¾ç‰‡ä¸‹è¡¨
            // const maskOffset = currentTime / danmakuMaskBlock
            // const pointOffset = Math.floor(maskOffset)
            // startTime = pointOffset
            // playtime = startTime
            // console.log(maskOffset, pointOffset)
            // console.log(currentTime)
            shouldStopTask=true
            AsyncRefreshMask()
        }

        videoPlayer.onpause = (event) => {
            console.log("pause")
            shouldStopTask = false
        }

        // æ¯éš”ä¸€æ®µæ—¶é—´æ›´æ”¹è’™ç‰ˆ URL
        function AsyncRefreshMask() {
            function loop() {
                if(!shouldStopTask){
                    return
                }
                // è·å–å½“å‰è§†é¢‘çš„æ—¶é—´
                const currentTime = Math.floor(videoPlayer.currentTime * 1000);
                const result = maskbst.findClosest(currentTime)
                // console.log(currentTime, result.key)
                var value = masksvgList[result.key];
                // console.log("æ›´æ¢è’™ç‰ˆ", value)
                maskUpdate(value)
                window.requestAnimationFrame(loop)
            }
            window.requestAnimationFrame(loop)
            // // å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œå®ç°æ­»å¾ªç¯
            // while(shouldStopTask){
            //     // è·å–å½“å‰è§†é¢‘çš„æ—¶é—´
            //     const currentTime = Math.floor(videoPlayer.currentTime * 1000);
            //     if (masksvgList.hasOwnProperty(currentTime)) {
            //         var value = masksvgList[currentTime];
            //         console.log("æ›´æ¢è’™ç‰ˆ", value)
            //         maskUpdate(value)
            //     }
            //     // ç­‰å¾…1æ¯«ç§’
            //     await new Promise(resolve => setTimeout(resolve, 1)); 
            //     ms ++
            // }
        }

        maskUpdate = function(target) {
            // å¾—åˆ°è’™ç‰ˆå›¾ç‰‡
            // const maskName = "image_" + String(target).padStart(5, '0') + ".svg"
            // const maskName = "image_" + String(target).padStart(5, '0') + ".svg"
            // console.log(maskName)

            // æ ¹æ®è§†é¢‘æ’­æ”¾æ—¶é—´åˆ‡æ¢ä¸åŒçš„å›¾ç‰‡è’™ç‰ˆ
            // danmakuLayer.style.mask = "url('svg/imgs/"+ maskName + "')"
            danmakuLayer.style.mask = "url('"+ target + "')"
            danmakuLayer.style.maskRepeat = "no-repeat"
            danmakuLayer.style.maskSize = "cover"
        }
    </script>
    <script>
        const danmakuposition = 500
        // è·å–å®¹å™¨å…ƒç´ 
        const container = document.getElementById('danmakuLayer');

        // ç”Ÿæˆéšæœºé¢œè‰²
        function getRandomColor() {
            return '#' + Math.floor(Math.random() * 16777215).toString(16);
        }

    
        // ç”Ÿæˆéšæœºä½ç½®
        function getRandomPosition() {
            return Math.floor(Math.random() * danmakuposition);
        }

        function getRandomFont() {
            const fonts = ['Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Times New Roman', 'Courier New'];
            return fonts[Math.floor(Math.random() * fonts.length)];
        }

        function getRandomSize(minSize, maxSize) {
            return Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
        }
    
        // åˆ›å»ºå¼¹å¹•å…ƒç´ 
        function createDanmu(text) {
            const danmu = document.createElement('div');
            danmu.classList.add('danmu');
            danmu.style.color = getRandomColor();
            danmu.style.fontSize =  getRandomSize(20, 350) + 'px';
            danmu.style.fontFamily = getRandomFont();
            danmu.style.top = getRandomPosition() + 'px';
            danmu.textContent = text;
            container.appendChild(danmu);
            // åŠ¨ç”»æ•ˆæœï¼šè®©å¼¹å¹•ä»å³å¾€å·¦æ»‘å‡º
            const animation = danmu.animate([
                { left: container.clientWidth + 'px', opacity: 1 },
                { left: '-' + danmu.clientWidth + 'px', opacity: 0 }
            ], {
                duration: 5000, // åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                easing: 'linear', // çº¿æ€§åŠ¨ç”»
                delay: 0, // å»¶è¿Ÿ0æ¯«ç§’å¼€å§‹åŠ¨ç”»
                iterations: 1, // åŠ¨ç”»æ’­æ”¾æ¬¡æ•°
                fill: 'both' // åŠ¨ç”»ç»“æŸæ—¶ä¿æŒæœ€åä¸€å¸§çš„çŠ¶æ€
            });
            // åŠ¨ç”»å®Œæˆåç§»é™¤å…ƒç´ 
            animation.onfinish = () => {
                danmu.remove();
            };
        }
        function generateRandomString(minLength, maxLength) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            // ğŸ‘ğŸ˜ğŸ‘ğŸ‘ğŸ˜ƒğŸ˜†ğŸ¥¹ğŸ¥¹ğŸ˜‡ğŸ™‚ğŸ˜ğŸ˜—ğŸ˜šğŸ˜šğŸ¤“ğŸ¥¸ğŸ¤©ğŸ¥³ğŸ˜ğŸ˜–ğŸ˜«
            const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }
            
        // æ¨¡æ‹Ÿå¼¹å¹•æ¶ˆæ¯
        setInterval(() => {
            if(!shouldStopTask){
                    return
            }
            // const messages = ['Hello', 'World', 'å¼¹å¹•æ•ˆæœ', 'OpenAI', 'ChatGPT'];
            const randomMessage = generateRandomString(20, 50)
            createDanmu(randomMessage);
        }, 100); // æ¯éš”2ç§’ç”Ÿæˆä¸€æ¡å¼¹å¹•æ¶ˆæ¯
    </script>
</body>
</html>
